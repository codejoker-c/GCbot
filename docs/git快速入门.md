# `git`快速入门

**Maoyao233 @GCBot**

> :information_source: 本文仍在持续**编写中**，欢迎提出意见与建议！

> 也许每一位对计算机稍有了解的同学都听说过世界上最大的~~同性交友网站~~开源社区 [Github](https://github.com)， 但坦白而言，Github对于新手而言并不是那么友好――作为一个基于分布式版本控制系统`git`之上的代码托管平台，如果使用者对`git`没有一定的了解，那么`fork`、`clone`、`pull request`这些概念也就会显得有些晦涩。许多萌新可能搜索下载文件都会感到吃力，遑论参与开源社区的协作开发了。（~~什么？Git和Github是两个东西？~~)
>
> 本文力求尽量不涉及复杂的概念，用最简单直接的方式让完全没有接触过`git`的同学对其形成直观印象，掌握其基本使用方法，并体会到它在协作开发中的价值。

## `git`是什么？

一言以蔽之：**`git`是一个版本控制工具**。

没错，`git`并非网站，而是一个软件。它实现的功能是“版本控制”，乍一听到似乎很难想到它和开源、共享、托管代码的 Github 有什么关系。那，什么是版本控制呢？我们又为什么需要它呢？

## 为什么需要`git`？

> 现在，你和同学需要合作完成一个大作业。你们很自然地使用QQ群来同步工作进度
>
> - “我加一个功能，你们等一下”
> - “诶，这个代码怎么不对啊？啊，你昨天晚上九点传的那份改了接口？我不知道啊”
> - “这个问题我解决了，在我两个小时前传的那个版本，你合并一下”
> - “出锅了？？等等，我手头的代码刚写一半还过不了编译，等我写完这点再来修”
> - "你前天中午加的那个代码有bug，得撤掉"
> - ……
> - ……
> - 你下载到的最新群文件：`BigHW(6)(2)(1).zip`

试想一下，如果在做的这个项目不是三人合作、一周以内搞定的大作业，而是一个有几十上百名程序员参与，开发周期以年记的大型工程呢？相信读者已经能想像到画面了，也大概就能认同我的观点了：团队合作中，版本控制绝对不可或缺。

`git`就是一个能够把我们从上面这个地狱中解放出来的神器。它可以很出色地做到以下几点：

1. 记录每个文件的提交与修改历史，对于每一行代码，都能轻松追溯到是谁、在什么时间、以什么理由对其作出了什么修改
2. 可以容易地将一个或一组文件回退至某个历史节点，也能在想要的时候找出来这些被回退掉的更改
3. 在某一个版本的基础上开展分支，分支之间互不干扰、可以切换，每个人可以在自己的独立分支上开发；开发到一半时，如果有紧急的新增功能或修复bug需求，也可以开辟新分支进行修复，而不受目前未完成工作的干扰
4. 提供了一系列解决冲突的方案，最大程度地帮助合并不同的分支

另外，`git`是一个**分布式**的系统，这意味着它并不需要一个中心化的服务器：哪怕你连接不上网络，也可以在自己本地的`git`项目上进行开发；可以从任何一个人的机器上恢复整个项目的进度，而不用担心服务器挂掉。

## 怎么使用`git`？

### 安装

首先，`git`是一个软件――所以你自然需要下载安装它。

我们可以在([Git - Downloads (git-scm.com)](https://git-scm.com/downloads)下载到它的最新版本。我们以 Windows 为例，简单看一下安装过程：

> 如果你使用的是其他操作系统，可以从[Git - 安装 Git (git-scm.com)](https://git-scm.com/book/zh/v2/起步-安装-Git)取得帮助。另外，比较 Geek 的同学可能会倾向于使用`Chocolatey` 或者 `Scoop` 一类工具安装`git`――但我相信这类同学也不需要我的这篇入门教程了。

![image-20210906214110393.png](http://1.15.150.183:2333/images/2021/09/09/V8spDjjmd2VigeV2.png)

尽管相比起大部分软件而言，`git`的安装过程中可以调节的选项要多不少，但是对于萌新而言，一路 Next 基本上就可以完成安装过程了。唯一值得注意的是下面这一页中，可以选择`git`所使用的文本编辑器：

![image-20210906214723011.png](http://1.15.150.183:2333/images/2021/09/09/Mvck3kdlXbSq3UlW.png)

可以看到，默认的安装选项是 Vim ――这并不是一个对入门者友好的选择。如果你不能熟练使用 Vim，请在这一步选择你常用的编辑器。此处支持 VS Code、Notepad++、Sublime 等主流编辑器；当然，如果以上列出的这些你都没有用过，那么也可以像下图一样，选择 Notepad，也就是 Windows 自带的记事本。

![image-20210906215403776.png](http://1.15.150.183:2333/images/2021/09/09/6sMdOZMl64mMksDo.png)

如果你像笔者一样按照默认配置安装好了最新的`git`，那么此时，在开始菜单中可以找到名为`Git Bash`的软件，打开它，在其中输入`git --version`，你应该就可以看见如下图所示的文字了：

![image-20210908221755203.png](http://1.15.150.183:2333/images/2021/09/09/YQOAB71r98bJt8E0.png)

> Git Bash 是`git`自带的命令行，提供了一个非常接近于 Linux Bash 的命令行环境，在里面可以无障碍地使用`git`以及众多 Linux 下的常见工具（既包括最基本的`cat`/`vim`/ `less`，也有`grep`/`awk`/`sed`等等强大的工具）。尽管按照默认安装选项，我们也可以在普通的命令行中使用 `git`，但本文中统一使用 Git Bash 进行演示。另外，默认安装选项会将“在Git Bash中打开”添加至右键菜单，可以借此方便地直接在 Git Bash 中打开当前文件夹。

至此，我们就成功完成了`git`的安装。

> 实际上，`git`也有 portable 的版本，即无需安装，解压即可使用，有兴趣的同学可以自行尝试。
>
> 另外，`git`有图形化的客户端，很多开发环境中也集成有`git`，它们的友好程度、功能齐全程度各不相同，有一些可以说相当好用；但笔者仍推荐掌握在命令行中使用`git`的基本方法，因为这是最为基础、也最为通用的使用形式，并且在熟练之后也就自然能理解各种图形界面的工作逻辑了。

### 获取`git`仓库

`git`使用**仓库**(repository， 也常用其简写repo)来存储、管理项目。一个仓库可以理解为被`git`所管理的文件夹，以及它内部的所有文件与子文件夹。有两种方式在本地得到一个仓库：

1. 将一个尚未进行过版本控制的本地目录建设成仓库

   只需要进入该目录，在命令行（或Git Bash， 根据实际情况和个人习惯选择，后文不再区分）中输入`git init`，即可完成这一操作。此时，可以看到该目录下出现了一个名为`.git`的隐藏文件夹，这就是`git`仓库的标志，也是`git`存储数据的位置。

   > 有的时候，如果你想要复制一个仓库中的文件，而不太关心它的版本历史，可以选择不复制`.git`文件夹――它往往会非常大

2. 从其他地方**克隆**(Clone)一个现有的仓库

   如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想把发布在 Github 上的项目同步到本地研究，或者为某个开源项目贡献自己的一份力，这时就要用到 `git clone` 命令。其格式为`git clone <url>`。此处的`<url>`支持多种协议，但对于新手而言，大部分场景都是从 Github 克隆一个项目。比如，要克隆`GCBot`仓库，我们可以进入其[ Github 页面](https://github.com/lllbbbyyy/GCbot)：

![image-20210906234955997.png](http://1.15.150.183:2333/images/2021/09/09/2nJfP1zsIsdT7l89.png)

   点击 Code 按钮，即可看到该仓库的链接。使用`git clone`命令克隆该仓库：

   ```bash
   git clone https://github.com/lllbbbyyy/GCbot.git
   ```

   即可看到在当前目录下多出了`GCbot`这一文件夹，也就是我们所得到的仓库。

   > 如果想要让`clone`下来的文件夹换一个名字，只需使用`git clone <url> <director>`方式，也就是在后面加上目标目录的名字。

### 暂存更改

当我们得到了一个`git`仓库之后，你就可以在其中进行开发了。通常，你会对一部分文件进行增加、删除、修改。`git`并不会自动记录下你的所有操作――因此，每当完成了一个小目标，你都需要手动将你的工作保存下来。

我们可以看一个简单的例子。使用`cd`命令进入我们刚刚克隆得到的仓库，并输入`git status`命令，即可看到如下的信息：

   ```bash
   $ git status
   On branch dev
   Your branch is up to date with 'origin/dev'.
   
   nothing to commit, working tree clean这里面涉及到 branch，也就是分支的信息我们会在下一节详细陈述。最后一行提示表明，此时仓库中没有任何未保存的变更。
   ```

接下来，我们在`docs`目录下创建一个文件，重新使用`git status`查看：

   ```bash
   $ git status
   On branch dev
   Your branch is up to date with 'origin/dev'.
   
   Untracked files:
     (use "git add <file>..." to include in what will be committed)
           docs/git快速入门.md
   
   nothing added to commit but untracked files present (use "git add" to track)
   ```

 `git`已经察觉到了刚刚添加的文件，将它标记为`Untracked files`，并提示我们可以用`git add`指令去追踪它。所谓`Untracked`，可以简单理解为它的存在和修改都不会被`git`所记录，如果此时其他人与你同步`git`仓库，它也不会被同步。为了记录它，我们可以使用`git add`指令。

   ```bash
   $ git add docs/git快速入门.md
   ```

> `git add`支持使用*来匹配任意字符，因此我们可以使用`git add *.cpp`这样的操作来一次性添加所有后缀为`.cpp`的文件；另外一个常用的操作是`git add .`，它可以添加当前目录下的所有文件。

此时再使用`git status`时，得到以下的提示信息：

   ```bash
   $ git status
   On branch dev
   Your branch is up to date with 'origin/dev'.
   
   Changes to be committed:
     (use "git restore --staged <file>..." to unstage)
           new file:   docs/git快速入门.md
   ```

可以看到，此时我们刚添加的文件已经被标记了"new file"，同时提示我们，这是“尚未提交的更改”。如果读者此前看过其他的`git`教程，会知道：`git add`仅仅是将文件添加到暂存区，还需要再使用`git commit`将其提交；但是，虽然它名为`commit`，提交的位置却是本地仓库，而不是直接提交到 Github 上的远程仓库，如果想要提交到远程仓库，需要在此基础上使用`git push`。根据笔者的经验，很多入门的同学会在此感到困惑，因此我们还是花一点时间说明`git`这样设计的目的和好处。

   > 如果读者想要有快速、连贯的入门体验，这里提供一个快速操作指南：使用
   >
   > ``` bash
   > git commit -m "本次修改的原因"
   > ```
   >
   > 本次修改就被记录下了，这个记录可以认为是永久性的，不再会丢失；然后，使用`git push`，即可将刚刚的修改提交到远端。当然，本地版本和远端版本可能会存在冲突导致`push`失败，此时应当参照[冲突解决]()一节处理。

   ### 暂存区与提交记录

前文中提到，`git`一个重要的好处是它提供了清楚的历史记录：我们可以很容易地追溯到某个文件的某一行是谁在什么时候出于什么目的而修改的。为了达到这个效果，`git`要求使用者在每次修改时都应当描述自己这次修改做了什么事情。很显然，最理想的状态是每条描述信息对应逻辑上的“一件事”：增加了某个功能、修复了某个bug，亦或是调整了文件格式。这样，我们可以容易地去查看某个操作变更了哪些代码，或者单独排除掉某个带来了副作用的操作。这样的一次修改，在`git`的逻辑中称为`commit`。

> 关于从仓库中恢复丢失的数据，以及减小仓库的大小，可以参见[Git - 维护与数据恢复 (git-scm.com)](https://git-scm.com/book/zh/v2/Git-内部原理-维护与数据恢复#_data_recovery)一节。
>
> :warning: **该内容属于`git`的高级知识，不适合初学者阅读！**

`commit`有一个很重要的特性：只要提交了，它几乎在任何情况下都是**可恢复**的。这一方面意味着数据有了保障，另一方面也要求你应当谨慎地对待这一指令――如果你不小心把一些非常大、而且经常会有变更的文件（例如`node.js`的`node_modules`文件夹）提交到了仓库中，会导致`git`仓库为了存储它们的历史而迅速膨胀，难以正常上传与下载；而你想要去清理它则非常非常困难，超出了大部分初学者的能力范围。

所以，我们应当精心选择每一次`commit`所包含的文件，以方便查阅、防止误添加。

但实际上，我们想要存储的更改，大部分都并不适合直接作为一个`commit`――有可能我们只完成了某一功能的一半，想留待下次继续编写；也有可能我们一次性做好了多件事，在逻辑上应当分成多个`commit`；也有可能，我们刚刚将一个不应该被`git`追踪的大型文件放进了仓库。因此，我们必然需要**暂存区**来存放这些变更。前面我们所讲述的`git add`命令，实际上就是将文件――准确来说是文件的**快照**――添加到暂存区。

快照，顾名思义，就是给文件“拍了个照片”，记录下了那一时刻文件的内容。因此，添加到暂存区的文件如果继续修改，暂存的内容也不会改变，直到你再次用`git add`命令覆盖掉上一次快照――没错，添加新文件、追加文件修改内容，用的都是`git add`指令。

> 关于暂存区的种种细节，包括移除、移动、比较更改、忽略文件等等，请读者在完成本教程后另行阅读[Git - 记录每次更新到仓库 (git-scm.com)](https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库)

当我们准备好了需要提交的内容（前文所说的，逻辑上的“一件事”）时，可以使用`git commit`指令发起一次提交请求。此时，`git`将会打开你[安装时](#安装)所选择的文本编辑器，要求你在其中留下这次`commit`内容的说明性文字。以#开头的行为注释，不会实际出现在提交内容中。一般来说，实际项目都会对`commit`时的附加信息有一定的[规范性要求](https://zhuanlan.zhihu.com/p/182553920)。在打开的编辑器窗口中撰写完成后，保存并关闭编辑器即可。

![image-20210909001229307.png](http://1.15.150.183:2333/images/2021/09/09/AW6rhA80thsibwPv.png)

   > 如果你在安装时保留了默认选项，那么此时会打开 Vim。你有两个选择：[学会它](https://riptutorial.com/vim)，或者[换掉它](https://git-scm.com/book/zh/v2/附录-C%3A-Git-命令-设置与配置)。

   当提交信息非常简短时，也可以使用`git commit -m <message>`的方式，直接将信息写在指令中。

   ### 与远端仓库同步

   > :warning:尚未完成编写

